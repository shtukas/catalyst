# encoding: UTF-8

=begin

The reason why we have structure is because I love seeing this

[
  {
    "name": "non trading",
    "account": "5167c421-dc33-42f0-81be-4c813e9df455",
    "data": [
      {
        "name": "waves",
        "account": "30185703-3A38-4030-B77A-477D6F2B7889",
        "rt": 0.0
      },
      {
        "name": "items non wave",
        "account": "BBC40E2A-C54F-4637-A6E1-F3DC62D37607",
        "rt": 0.4
      }
    ],
    "rt": 1.4755555555555555
  },
  {
    "name": "trading",
    "account": "b61f7e245313b7183627b3ec0f1c59cc",
    "rt": 4.024236111111111
  }
]

=end

class Dispatch

    # Dispatch::structure()
    def self.structure()
        a = [
            {"name" => "items non wave", "account" => "BBC40E2A-C54F-4637-A6E1-F3DC62D37607"},
            {"name" => "waves", "account" => "30185703-3A38-4030-B77A-477D6F2B7889"},
        ]
            .map{|packet|
                packet["rt"] = BankDerivedData::recoveredAverageHoursPerDay(packet["account"])
                packet
            }
            .sort_by{|packet| packet["rt"] }
        [
            {"name" => "trading", "account" => "b61f7e245313b7183627b3ec0f1c59cc"},
            {"name" => "non trading", "account" => "5167c421-dc33-42f0-81be-4c813e9df455", "data" => a}
        ]
            .map{|packet|
                packet["rt"] = BankDerivedData::recoveredAverageHoursPerDay(packet["account"])
                packet
            }
            .sort_by{|packet| packet["rt"] }
    end

    # Dispatch::packet_to_items(packet, collection)
    def self.packet_to_items(packet, collection)
        if packet["data"] then
            return Dispatch::structure_to_items(packet["data"], collection)
        end
        if packet["name"] == "items non wave" then
            return collection.select{|item| item["mikuType"] != "Wave" }
        end
        if packet["name"] == "waves" then
            return collection.select{|item| item["mikuType"] == "Wave" }
        end
        if packet["name"] == "trading" then
            return collection.select{|item| item["uuid"] == "b61f7e245313b7183627b3ec0f1c59cc" }
        end
        if packet["name"] == "non trading" then
            return collection.select{|item| item["uuid"] != "b61f7e245313b7183627b3ec0f1c59cc" }
        end
    end

    # Dispatch::structure_to_items(structure, collection)
    def self.structure_to_items(structure, collection)
        structure.map{|packet| Dispatch::packet_to_items(packet, collection) }.flatten
    end

    # Dispatch::itemsForListing(items)
    def self.itemsForListing(items)

        # The items arrive in the listing position (they were originally 
        # generated by FrontPage::itemsForListing() which applies the listing 
        # order).

        head, items = items.partition{|item| NxBalls::itemIsActive(item) or (item["mikuType"] == "Wave" and item["interruption"]) }

        if head.size > 0 then
            # section alpha
            return head + items.sort_by{|item| XCache::getOrDefaultValue("daee4d1a-94fd-4ed1-9233-a659615f73af:#{item["uuid"]}", "6").to_f }
        end

        items = Dispatch::structure_to_items(Dispatch::structure(), items)

        items.each_with_index{|item, i|
            XCache::set("daee4d1a-94fd-4ed1-9233-a659615f73af:#{item["uuid"]}", i)
        }

        items
    end
end
