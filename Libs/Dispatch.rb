# encoding: UTF-8

class Dispatch

    # Dispatch::incoming_duration_for_the_record(item, duration_in_seconds)
    def self.incoming_duration_for_the_record(item, duration_in_seconds)
        if item["durations-mins-40"].nil? then
            durations = [{"date" => CommonUtils::nDaysInTheFuture(-1), "mins" => 20}]
            item["durations-mins-40"] = durations
            Blades::setAttribute(item["uuid"], "durations-mins-40", durations)
        end
        if item["durations-mins-40"].last["date"] == CommonUtils::today() then
            last_entry = item["durations-mins-40"].last.clone
            last_entry["mins"] = last_entry["mins"] + duration_in_seconds.to_f/60
            item["durations-mins-40"] = item["durations-mins-40"].reverse.drop(1).reverse + [last_entry]
        else
            item["durations-mins-40"] = item["durations-mins-40"] + [{"date" => CommonUtils::today(), "mins" => duration_in_seconds.to_f/60}]
        end
        Blades::setAttribute(item["uuid"], "durations-mins-40", item["durations-mins-40"])
    end

    # Dispatch::decide_duration_in_mins(item)
    def self.decide_duration_in_mins(item)

        if item["durations-mins-40"].nil? then
            durations = [{"date" => CommonUtils::nDaysInTheFuture(-1), "mins" => 20}]
            item["durations-mins-40"] = durations
            Blades::setAttribute(item["uuid"], "durations-mins-40", durations)
        end

        entries = item["durations-mins-40"]
        entries = entries.select{|entry| entry["date"] < CommonUtils::today() }
        sum = entries.map{|entry| entry["mins"] }.sum
        duration = sum.to_f/entries.size

        # So technically we will have received, items that are either
        # waves or tasks (non waves).
        # We apply the multiplier to tasks.

        if item["mikuType"] != "Wave" then
            duration = duration * Dispatch::taskDurationMultiplier()
        end

        duration
    end

    # Dispatch::decide_deadline_or_null()
    def self.decide_deadline_or_null()
        if Time.new.hour < 12 then
            unixtime = DateTime.parse("#{CommonUtils::today()} 12:00:00").to_time.to_i
            return {
                "unixtime" => unixtime,
                "datetime" => Time.at(unixtime).to_s
            }
        end
        if Time.new.hour < 16 then
            unixtime = DateTime.parse("#{CommonUtils::today()} 16:00:00").to_time.to_i
            return {
                "unixtime" => unixtime,
                "datetime" => Time.at(unixtime).to_s
            }
        end
        if Time.new.hour < 22 then
            unixtime = DateTime.parse("#{CommonUtils::today()} 21:00:00").to_time.to_i
            return {
                "unixtime" => unixtime,
                "datetime" => Time.at(unixtime).to_s
            }
        end
        nil
    end

    # Dispatch::taskDurationMultiplier()
    def self.taskDurationMultiplier()
        # Functions that helps waves to show up until noon, by artificially
        # Reducing the item duration
        # We want a value 0 until 6 am
        # Progress from 0 to 1 until 12
        # 1 from 12
        idx = Time.new.to_i + Time.new.min.to_f/60
        return 0 if idx <= 6
        if idx > 6 and idx <= 12 then
            (idx - 6)/6
        end
        1 # For values of idx greater than 12
    end

    # Dispatch::sequence_meets_deadline(items, deadline)
    def self.sequence_meets_deadline(items, deadline)
        cursor_end_task = Time.new.to_i
        cursor_end_task_non_wave = Time.new.to_i
        items.each{|item|
            cursor_end_task = cursor_end_task + Dispatch::decide_duration_in_mins(item) * 60
            if item["mikuType"] != "Wave" then
                cursor_end_task_non_wave = cursor_end_task
            end
        }
        cursor_end_task_non_wave < deadline["unixtime"]
    end

    # Dispatch::dispatch(prefix, tasks, waves, depth, deadline)
    def self.dispatch(prefix, tasks, waves, depth, deadline)
        return prefix + tasks if waves.empty?
        return prefix + waves + tasks if depth > waves.size
        return prefix + waves + tasks if deadline.nil?
        if Dispatch::sequence_meets_deadline(prefix + waves.take(depth+1) + tasks + waves.drop(depth+1), deadline) then
            return Dispatch::dispatch(prefix, waves, tasks, depth+1, deadline)
        end
        prefix + waves.take(depth) + tasks + waves.drop(depth)
    end

    # Dispatch::itemsForListing(items)
    def self.itemsForListing(items)

        # The items arrive in the listing position (they were originally 
        # generated by FrontPage::itemsForListing() which applies the listing 
        # order).

        head, items = items.partition{|item| NxBalls::itemIsActive(item) or (item["mikuType"] == "Wave" and item["interruption"]) }

        if head.size > 0 then
            # section alpha
            return head + items.sort_by{|item| XCache::getOrDefaultValue("daee4d1a-94fd-4ed1-9233-a659615f73af:#{item["uuid"]}", "6").to_f }
        end

        deadline = Dispatch::decide_deadline_or_null()

        waves, tasks = items.partition{|item| item["mikuType"] == "Wave" }

        # We prioritise the waves that have been listed for more than 2 days.
        w1, w2 = waves.partition{|wave| wave["listing-marker-57"] and (Time.new.to_i - wave["listing-marker-57"] ) > 86400 * 2 }

        items = Dispatch::dispatch(head + w1, tasks, w2, 0, deadline)

        # Now that we have an ordering, I am going to store it so that it can be
        # used again if we enter section alpha above. This means that things
        # will keep their place if and when a head appears, which happens when
        # an there is a running item.
        items.each_with_index{|item, i|
            XCache::set("daee4d1a-94fd-4ed1-9233-a659615f73af:#{item["uuid"]}", i)
        }

        items



    end
end
