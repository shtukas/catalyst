# encoding: UTF-8

class Dispatch

    # Dispatch::itemsForListing(items)
    def self.itemsForListing(items)

        # The items arrive in the listing position (they were originally 
        # generated by FrontPage::itemsForListing() which applies the listing 
        # order).

        head, items = items.partition{|item| NxBalls::itemIsActive(item) or (item["mikuType"] == "Wave" and item["interruption"]) }

        if head.size > 0 then
            # section alpha
            return head + items.sort_by{|item| XCache::getOrDefaultValue("daee4d1a-94fd-4ed1-9233-a659615f73af:#{item["uuid"]}", "6").to_f }
        end

        # operation stratcom trading interception
        interception = []
        #  trading < everything-else
        if BankDerivedData::recoveredAverageHoursPerDay("883287db-871b-4c9a-9d8e-85fed2cbd1a3") < BankDerivedData::recoveredAverageHoursPerDay("5167c421-dc33-42f0-81be-4c813e9df455") then
            interception = [ Blades::itemOrNull("b61f7e245313b7183627b3ec0f1c59cc") ].compact
        end

        # We are now in the case where we do not have active or wave:interruption items
        # and we do not have to focus on trading.
        # The choice now is between regular waves and other items

        non_waves, waves = items.partition{|item| item["mikuType"] != "Wave" }

        metric_wave = BankDerivedData::recoveredAverageHoursPerDay("30185703-3A38-4030-B77A-477D6F2B7889")
        metric_non_wave = BankDerivedData::recoveredAverageHoursPerDay("BBC40E2A-C54F-4637-A6E1-F3DC62D37607")
        if metric_wave < metric_non_wave then
            items = waves + non_waves
        else
            items = non_waves + waves
        end

        items.each_with_index{|item, i|
            XCache::set("daee4d1a-94fd-4ed1-9233-a659615f73af:#{item["uuid"]}", i)
        }

        items
    end
end
